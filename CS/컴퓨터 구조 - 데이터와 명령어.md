# 컴퓨터 구조 - 컴퓨터의 구성 요소

## 데이터

[정보 단위]

비트 : 컴퓨터가 이해하는 가장 작은 정보 단위. 0과 1로 표현됨

- n개당 2의 n승만큼 정보를 표헌할 수  있음.
- 1byte = 8 bits, 1kb = 1000bytes
- 워드 : CPU가 한 번에 처리가능한 데이터 크기. 대부분 32비트 또는 64비트

보수 : 이진법에서 0,1을 반전 시킨 음수 값. 다만, 음수임을 알기 위하여 플래그를 사용함. Ex). 0101 = 5 or -11



[인코딩 / 디코딩]

인코딩 / 디코딩 : 문자를 읽을 수 있게 변환 / 해석하는 과정

- 아스키 코드 : 7비트짜리 문자 집합으로 영어 알파벳, 숫자, 특수문자를 표현할 수 있음

- 유니 코드 : 아스키코드 이상의 다양한 문자를 대응하기 위한 인코딩 방식으로 모든 문자를 표현하고자함
  - UTF-8, 16, 32 : 유니코드를 인코딩 하는 방식. UTF-8이 가장 대중적이나 상황에 따라서 16, 32 등이 유리하여 이를 사용함.



## 명령어

[고급 언어 vs 저급 언어]

저급 언어 : 기계어, 어셈블리어

- 기계어 : 0과 1 또는 16진수로 이루어진 언어
- 어셈블리어 : 기계어를 읽기 쉽게 번역한 언어. 실행 순서를 쉽게 알 수 있음

고급 언어 : C++, C, Java

- 사람이 읽기 쉬운 언어. 고차원적인 일을 할 때 자주 사용함.



[컴파일 언어 vs 인터프리터 언어]

컴파일 언어 : 소스 코드 전체가 저급 언어로 변환되는 언어 ex). C

- 컴파일 : 저급언어로 변환하는 과정
- 컴파일러 : 컴파일은 수행하는 도구
- 목적코드 : 컴파일러를 통해 변환된 저급 언어
- 링킹 : 목적코드에서 

인터프리터 언어 : 소스 코드를 한 줄씩 차례로 실행하고 변환하는 언어

인터프리터 vs 컴파일 언어

- 인터프리터는 한 줄씩 실행되기에 에러코드를 만나기 전까지는 실행할 수 있음. 하지만, 컴파일은 에러가 있으면 컴파일이 되지 않아서 모두 실행되지 않음
- 컴파일이 인터프리터보다 빠름
- 요즘은 둘을 하이브리드로 사용하여서 둘이 명확히 나누어지지 않음



[명령어 구조]

명령어 = 연산코드 + 오퍼랜드

- 연산 코드 : 명령어가 수행할 연산
  - CPU마다 조금씩 다름
  - 데이터 전송 , 산술/논리 연산, 제어 흐름 변경, 입출력 제어 등의 역할을 수행하는 명령어가 존재함.
- 오퍼랜드 : 연산에 사용될 데이터가 저장된 위치
  - 메모리 주소나 레지스터 이름이 담겨서 주소 필드라 부르기도 함.
  - 명령어는 0~3개 등 여러 개일 수 있음
  - 즉시 주소 지정 방식 : 오퍼랜드 필드에 데이터를 직접 명시하여 빠르나, 데이터가 작아짐
  - 직접 주소 지정 방식 : 유효 주소를 명시하는 방식. 좀 더 데이터 크기가 커지나 살짝 느러짐
  - 간접 주소 지정 방식 : 유효 주소의 주소를 명시하는 방식. 두 번 메모리에 접근하기 때문에 느려짐.
  - 레지스터 주소 지정 방식 : 직접 주소 지정 방식과 동일하나, 레지스터의 주소를 지정함. (레지스터 접근이 더 빨라서 조금 더 빠름)
  - 레지스터 간접 주소 지정 방식 : 간접 주소 지정 방식과 동일함.
  - 상대 주소 지정 방식 : 프로그램 카운터에서 오퍼랜드의 값을 더하여 유효 주소를 얻는 방식
  - 베이스 레지스터 주소 지정 방식 : 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식




## 명령어 사이클과 인터럽트

명령어 사이클 : 명령어를 수행하는 흐름

- 인출 사이클 : 명령어를 가져오는 과정
- 실행 사이클 : 명령어를 실행하는 과정
- 간접 사이클 : 인출 중 한 번 더 메모리에 접근해야하는 과정

인터럽트 : 명령어 수행이 끊어지는 현상

- 동기 인터럽트(예외)
  - 폴트(fault) : 데이터 등이 부족할 때, 일시적으로 중단했다가 문제가 해결되면 예외가 발생한 부분부터 다시 진행함
  - 트랩(trap) : 예외가 발생한 다음 명령어부터 진행함. (디버깅 시 주로 사용)
  - 중단(abort) : 치명적 문제가 발생하여 정지
  - 소프트웨어 인터럽트 : 시스템 호출 발생 시 발생
- 비동기 인터럽트
  - 하드웨어 인터럽트 : 하드웨어의 요청을 처리할 때 정지하는 현상. 하드웨어의 요청이 처리가 될 때까지 CPU는 다른 일을 진행함 비동기의 대부분이 하드웨어 인터럽트임
  - 인터럽트 핸들러 : 인터럽트 요청이 왔으며, 이를 수행해야하는 경우 인터럽트를 처리하기 위하여 실행되는 프로그램
    - 인터럽트 요청 : 인터럽트에 대한 요청. 플래그에 따라서 거절할 수도 있지만 거절할 수 없는 요청도 존재함 
    - 인터럽트 벡터 : 어떤 인터럽트 서비스 루틴을 수행할 지 서비스 루틴의 시작 주소를 알려줌
    - 인터럽트 처리 : 서비스 루틴을 실행 후, 정지했던 프로그램으로 돌아옴



## CPU 설계

클럭 속도 향상 : 클럭이 높으면 빨라진다. 하지만, 발열 등의 문제가 발생한다.

멀티코어 도입 : 코어가 많으면 일 할 사람이 많은 것과 같음

- 코어 : CPU 내 명령어를 실행하는 제품
- 코어가 너무 많아도 다시 효율이 낮은 상황이 올 수도 있음.

멀티스레드 도입 : 

- (하드웨어적) 스레드 : 하나의 코어가 동시에 처리할 수 있는 명령어의 수. 논리 프로세서라고도 부름
- (소프트웨어적) 스레드 : 하나의 프로그램에서 실행되는 명령의 단위
- 멀티스레드(하이퍼스레딩) : 하나의 코어로 여러 명령어를 동시 처리 하는 것



## 명령어 병렬 처리 (ILP)

명령어 파이프 라인 (파이프 라이닝)

- 인출 - 해석 - 실행 - 결과 저장의 과정을 단계별로 겹쳐서 실행하는 방법으로 매우 효율적임
- 파이프라인 위험 : 파이프 라이닝을 실패하게 만드는 요소들
  - 데이터 위험 : 명령어의 우선 순위 또는 데이터 간 의존성이 존재하여 명령어가 병렬적으로 동작하지 않는 현상
  - 제어 위험 : 프로그램 카운터가 실행되면서 변화가 생겨서 진행 중인 병렬작업의 의미가 사라지는 현상
    - 분기 예측 : 미리 분기를 예측하여서 이를 방지하는 기술
  - 구조적 위험 : CPU 등의 자원을 동시에 사용하게 되는 위험

슈퍼스칼라 : 병렬 파이프라이닝 적용

비순차적 명령어 처리(OoOE) : 데이터 의존성이 있는 명령어의 순서를 늦게 처리하는 방식. 슈퍼스칼라와 파이프라이닝은 순차적인 처리를 기준으로 함. 



## CISC / RISC

ISA(명령어 집합 구조) : CPU마다 다룰 수 있는 명령어들의 집합

- ISA가 다르면, 실행할 수 있는 명령어와 어셈블리어가 다르다. ex). 애플과 intel에서 같은 코드를 사용해도 이해할 수가 없다!
- 명령어에 따라서, CPU의 성능이 달라진다.

CISC(복잡한 컴퓨터 명령어 집합) : 형태와 크기가 다양한 가변 길이 명령어를 사용

- 장점 : 메모리가 절약되고 명령어 수가 적음
- 단점 : 크기와 실행시간이 일정하지 않음 = 파이프라이닝에서 불리함
- 단점2 : 복잡한 명령어는 거의 사용하지 않음

RISC (줄어든 명령어 집합) : CISC의 단점 극복하고자 고정 길이 명령어를 사용

- 장점 : 파이프라이닝의 최적화
- 장점2 : 메모리 접근을 단순화하고 최소화를 추구함. (Load-store 구조)
- 단점 : 명령어 수가 많아짐



## 메모리와 캐시

[메모리 종류]

DRAM : 시간이 지나면 데이터가 자동으로 사라짐. 하지만 쌈

SRAM : 데이터가 계속 유지되고 빠름. 하지만 비쌈 그래서 캐시에서 사용됨

SDRAM : 클럭과 동기화된 DRAM

DDR SDRAM : 대역폭을 넓혀서 속도를 빠르게 만든 SDRAM



[메모리의 주소]

물리 주소 : 메모리 하드웨어가 사용하는 주소. 

논리 주소 : CPU와 실행 중인 프로그램이 사용하는 주소

- 각각 0부터 시작되는 프로그램만의 상대주소가 존재함
- MMU(메모리 관리 장치와 내부 베이스 레지스터)에 의해서 논리 주소가 실제 물리 주소로 변경됨
- 베이스 레지스터 : 해당 프로그램의 가장 작은 물리적 주소를 저장함
- 한계 레지스터 : 해당 프로그램의 가장 큰 물리적 주소를 지정함 이를 통해서 메모리를 보호함



[캐시]

저장 장치 계층 구조 : CPU에 가까운 정도를 의미함

[사진]

캐시 분리 

- L1, L2, L3로 캐시를 구분하여 캐시를 더 세분화하고 강화시킴
- L1, L2는 보통 코어 내, L3는 코어 공유 캐시로 사용
- L1 캐시를 목적에 따라서 다시 세분화하는 분리형 캐시도 존재함.

캐시 히트 : 캐시 메모리 내에서 저장된 자료가 사용되는 것

캐시 미스 : 저장하였으나, 다시 가져와야하는 경우

캐시 적중률 : 캐시 히트 / (캐시 히트 + 캐시 미스)

참조 지역성의 원리

- 시간 지역성 : CPU는 최근에 접근했던 메모리 공간에 다시 접근하려한다.
- 공간 지역성 : CPU는 접근한 메모리 공간 근처를 접근하려는 경향이 있다.

=> 이를 바탕으로 캐시 적중률을 높임



## 보조기억장치

[하드 디스크의 구성 요소]

- 플래터 : 데이터를 저장하는 원판. NS극을 이용하여 0,1 형태로 저장
- 스핀들 : 플래터를 회전시키는 요소
- 헤드 : 데이터를 읽고 쓰는 구성 요소. 디스크 암 끝에 헤드가 달려있음.
- 디스크 암 : 헤드의 위치를 조절하는 요소
- 트랙 : 동심원의 한 영역
- 섹터 : 동심원을 등분한 조각
- 실린더 : 같은 위치의 있는 플래터의 모든 트랙들 

[읽는 시간]

- 탐색 시간 : 저장된 데이터에 접근하기 위해서 헤드를 이동시키는 시간 
- 회전 지연 : 회전 시키는 시간
- 전송 시간 : 데이터를 전송시키는 시간

[탐색 시간 사진]



[플래시 메모리]

반도체 기반의 전기 저장 장치로 SLC, MLC, TLC 등이 존재함.

셀 < 페이지 < 블록 < 플레인 < 다이 순으로 커지며 읽기와 쓰기는 페이지 단위로 삭제는 블록 단위로 이루어짐.

페이지는 Free(빈 상태), Valid(유효한 값), InValid(쓰지 않는 쓰레기값)로 구분됨

- 플래시 메모리는 수정이 불가능하여 셀에 추가로 저장해야함.
- 이런 용량 낭비를 막기 위하여 가비지 컬렉션을 사용함. 
  - 가비지 컬렉션은 유효한 셀만을 새로운 블록에 옮기고 기존 불필요한 블록을 삭제함



[RAID]

여러 개의 물리적 보조기억장치를 하나의 논리적 기억장치처럼 사용하는 기술



[입출력 장치]

장치 컨트롤러 - 입출력 장치를 제어하고 도와주는 장치들

장치 컨트롤러의 역할

- CPU와 입출력 장치 간의 통신 중계
- 오류 검출
- 데이터 버퍼링 : 전송률(데이터가 전송되는 속도)을 맞추기 위한 작업

장치 컨트롤러 내부 구조

- 데이터 레지스터 : CPU와 주고 받을 데이터가 담기는 레지스터
- 상태 레지스터 : 준비 작업 여부, 오류 작업 여부
- 제어 레지스터 : 제어 정보와 명령을 저장

장치 드라이버 : 장치 컨트롤러가 컴퓨터 내부와 정보를 주고받을 수 있게하는 프로그램



[입출력 방법]

프로그램 입출력 : 프로그램 명령어가 입출력 명령어를 만나면 작동시키는 작업

- 메모리 맵 입출력 : 메모리 주소 공간과 입출력장치를 위한 주소 공간을 분리하는 방법
- 고립형 입출력 : 분리된 주소 공간을 사용하는 방법
- 인터럽트 기반 입출력 : 인터럽트 요청을 보내면 백업 후 서비스 루틴 실행
- 프로그래머블 인터럽트 컨트롤러 : 여러 입출력의 인터럽트를 통합 후 우선순위에 맞게 컨트롤할 수 있게 하는 장치
- DMA 입출력 : CPU를 거치치 않고 메모리와 직접 입출력을 주고받은 방식
  - 입출력 버스 : DMA 입출력 시, 시스템 버스를 독점하는 문제가 있어서 이를 해결하기 위하여 입출력 버스를 별도로 만들어서 사용
  - PCIe 버수 : 대표적인 입출력 버스
